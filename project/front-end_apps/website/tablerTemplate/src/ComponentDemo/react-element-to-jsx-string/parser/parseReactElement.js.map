{"version":3,"sources":["../../src/parser/parseReactElement.js"],"names":["supportFragment","Boolean","getReactElementDisplayName","element","type","displayName","name","noChildren","propsValue","propName","onlyMeaningfulChildren","children","filterProps","originalProps","cb","filteredProps","Object","keys","filter","key","forEach","parseReactElement","options","displayNameFn","isValidElement","Error","props","ref","search","defaultProps","childrens","Children","toArray","map","child"],"mappings":";;;;;;;;AAEA;;;;AAEA;;;;AAQA,IAAMA,kBAAkBC,wBAAxB;;AAEA,IAAMC,6BAA6B,SAA7BA,0BAA6B,CAACC,OAAD;AAAA,SACjCA,QAAQC,IAAR,CAAaC,WAAb,IACAF,QAAQC,IAAR,CAAaE,IADb,MACqB;AACpB,SAAOH,QAAQC,IAAf,KAAwB,UAAxB,CAAmC;AAAnC,IACG,iBADH,GAEGD,QAAQC,IAJZ,CADiC;AAAA,CAAnC;;AAOA,IAAMG,aAAa,SAAbA,UAAa,CAACC,UAAD,EAAaC,QAAb;AAAA,SAA0BA,aAAa,UAAvC;AAAA,CAAnB;;AAEA,IAAMC,yBAAyB,SAAzBA,sBAAyB,CAACC,QAAD;AAAA,SAC7BA,aAAa,IAAb,IACAA,aAAa,KADb,IAEAA,aAAa,IAFb,IAGAA,aAAa,EAJgB;AAAA,CAA/B;;AAMA,IAAMC,cAAc,SAAdA,WAAc,CAACC,aAAD,EAAoBC,EAApB,EAAqD;AACvE,MAAMC,gBAAgB,EAAtB;;AAEAC,SAAOC,IAAP,CAAYJ,aAAZ,EACGK,MADH,CACU;AAAA,WAAOJ,GAAGD,cAAcM,GAAd,CAAH,EAAuBA,GAAvB,CAAP;AAAA,GADV,EAEGC,OAFH,CAEW;AAAA,WAAQL,cAAcI,GAAd,IAAqBN,cAAcM,GAAd,CAA7B;AAAA,GAFX;;AAIA,SAAOJ,aAAP;AACD,CARD;;AAUA,IAAMM,oBAAoB,SAApBA,iBAAoB,CACxBlB,OADwB,EAExBmB,OAFwB,EAGX;AAAA,6BACuDA,OADvD,CACLjB,WADK;AAAA,MACQkB,aADR,wCACwBrB,0BADxB;;;AAGb,MAAI,OAAOC,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,WAAO,gCAAqBA,OAArB,CAAP;AACD,GAFD,MAEO,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AACtC,WAAO,gCAAqBA,OAArB,CAAP;AACD,GAFM,MAEA,IAAI,CAAC,gBAAMqB,cAAN,CAAqBrB,OAArB,CAAL,EAAoC;AACzC,UAAM,IAAIsB,KAAJ,0EACmEtB,OADnE,yCACmEA,OADnE,SAAN;AAGD;;AAED,MAAME,cAAckB,cAAcpB,OAAd,CAApB;;AAEA,MAAMuB,QAAQd,YAAYT,QAAQuB,KAApB,EAA2BnB,UAA3B,CAAd;AACA,MAAIJ,QAAQwB,GAAR,KAAgB,IAApB,EAA0B;AACxBD,UAAMC,GAAN,GAAYxB,QAAQwB,GAApB;AACD;;AAED,MAAMR,MAAMhB,QAAQgB,GAApB;AACA,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,IAAIS,MAAJ,CAAW,KAAX,CAA/B,EAAkD;AAChD;AACAF,UAAMP,GAAN,GAAYA,GAAZ;AACD;;AAED,MAAMU,eAAejB,YAAYT,QAAQC,IAAR,CAAayB,YAAb,IAA6B,EAAzC,EAA6CtB,UAA7C,CAArB;AACA,MAAMuB,YAAY,gBAAMC,QAAN,CAAeC,OAAf,CAAuB7B,QAAQuB,KAAR,CAAcf,QAArC,EACfO,MADe,CACRR,sBADQ,EAEfuB,GAFe,CAEX;AAAA,WAASZ,kBAAkBa,KAAlB,EAAyBZ,OAAzB,CAAT;AAAA,GAFW,CAAlB;;AAIA,MAAItB,mBAAmBG,QAAQC,IAAR,oBAAvB,EAAkD;AAChD,WAAO,uCAA4Be,GAA5B,EAAiCW,SAAjC,CAAP;AACD;;AAED,SAAO,sCACLzB,WADK,EAELqB,KAFK,EAGLG,YAHK,EAILC,SAJK,CAAP;AAMD,CA5CD;;kBA8CeT,iB","file":"parseReactElement.js","sourcesContent":["/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getReactElementDisplayName = (element: ReactElement<*>): string =>\n  element.type.displayName ||\n  element.type.name || // function name\n  (typeof element.type === 'function' // function without a name, you should provide one\n    ? 'No Display Name'\n    : element.type);\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n"]}