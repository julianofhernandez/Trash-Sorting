{"version":3,"sources":["../../src/formatter/formatReactFragmentNode.js"],"names":["REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","displayName","key","childrens","props","type","defaultProps","isKeyedFragment","Boolean","hasNoChildren","length","node","inline","lvl","options","Error","useFragmentShortSyntax"],"mappings":";;;;;;AAGA;;;;;;AAQA,IAAMA,uCAAuC,EAA7C;AACA,IAAMC,0CAA0C,gBAAhD;;AAEA,IAAMC,yBAAyB,SAAzBA,sBAAyB,CAC7BC,WAD6B,EAE7BC,GAF6B,EAG7BC,SAH6B,EAIJ;AACzB,MAAIC,QAAQ,EAAZ;AACA,MAAIF,GAAJ,EAAS;AACPE,YAAQ,EAAEF,QAAF,EAAR;AACD;;AAED,SAAO;AACLG,UAAM,cADD;AAELJ,4BAFK;AAGLG,gBAHK;AAILE,kBAAc,EAJT;AAKLH;AALK,GAAP;AAOD,CAjBD;;AAmBA,IAAMI,kBAAkB,SAAlBA,eAAkB;AAAA,MAAGL,GAAH,QAAGA,GAAH;AAAA,SAAoCM,QAAQN,GAAR,CAApC;AAAA,CAAxB;AACA,IAAMO,gBAAgB,SAAhBA,aAAgB;AAAA,MAAGN,SAAH,SAAGA,SAAH;AAAA,SACpBA,UAAUO,MAAV,KAAqB,CADD;AAAA,CAAtB;;kBAGe,UACbC,IADa,EAEbC,MAFa,EAGbC,GAHa,EAIbC,OAJa,EAKF;AAAA,MACHT,IADG,GACsBM,IADtB,CACHN,IADG;AAAA,MACGH,GADH,GACsBS,IADtB,CACGT,GADH;AAAA,MACQC,SADR,GACsBQ,IADtB,CACQR,SADR;;;AAGX,MAAIE,SAAS,eAAb,EAA8B;AAC5B,UAAM,IAAIU,KAAJ,oGAEFV,IAFE,CAAN;AAKD;;AATU,MAWHW,sBAXG,GAWwBF,OAXxB,CAWHE,sBAXG;;;AAaX,MAAIf,oBAAJ;AACA,MAAIe,sBAAJ,EAA4B;AAC1B,QAAIP,cAAcE,IAAd,KAAuBJ,gBAAgBI,IAAhB,CAA3B,EAAkD;AAChDV,oBAAcF,uCAAd;AACD,KAFD,MAEO;AACLE,oBAAcH,oCAAd;AACD;AACF,GAND,MAMO;AACLG,kBAAcF,uCAAd;AACD;;AAED,SAAO,sCACLC,uBAAuBC,WAAvB,EAAoCC,GAApC,EAAyCC,SAAzC,CADK,EAELS,MAFK,EAGLC,GAHK,EAILC,OAJK,CAAP;AAMD,C","file":"formatReactFragmentNode.js","sourcesContent":["/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${\n        type\n      }`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n"]}