{"version":3,"sources":["../../src/formatter/formatComplexDataStructure.js"],"names":["noRefCheck","value","inline","lvl","options","normalizedValue","stringifiedValue","transform","currentObj","prop","originalResult","currentValue","replace","tabStop"],"mappings":";;;;;;AAEA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAGA,SAASA,UAAT,GAAsB,CAAE;;kBAET,UACbC,KADa,EAEbC,MAFa,EAGbC,GAHa,EAIbC,OAJa,EAKF;AACX,MAAMC,kBAAkB,0BAAWJ,KAAX,CAAxB;;AAEA,MAAMK,mBAAmB,+BAAUD,eAAV,EAA2B;AAClDE,eAAW,mBAACC,UAAD,EAAaC,IAAb,EAAmBC,cAAnB,EAAsC;AAC/C,UAAMC,eAAeH,WAAWC,IAAX,CAArB;;AAEA,UAAIE,gBAAgB,2BAAeA,YAAf,CAApB,EAAkD;AAChD,eAAO,8BACL,iCAAkBA,YAAlB,EAAgCP,OAAhC,CADK,EAEL,IAFK,EAGLD,GAHK,EAILC,OAJK,CAAP;AAMD;;AAED,UAAI,OAAOO,YAAP,KAAwB,UAA5B,EAAwC;AACtC,eAAOX,UAAP;AACD;;AAED,aAAOU,cAAP;AACD;AAlBiD,GAA3B,CAAzB;;AAqBA,MAAIR,MAAJ,EAAY;AACV,WAAOI,iBACJM,OADI,CACI,MADJ,EACY,GADZ,EAEJA,OAFI,CAEI,KAFJ,EAEW,GAFX,EAGJA,OAHI,CAGI,KAHJ,EAGW,GAHX,EAIJA,OAJI,CAII,MAJJ,EAIY,GAJZ,EAKJA,OALI,CAKI,KALJ,EAKW,GALX,CAAP;AAMD;;AAED;AACA,SAAON,iBACJM,OADI,CACI,KADJ,EACW,sBAAO,CAAP,EAAUR,QAAQS,OAAlB,CADX,EAEJD,OAFI,CAEI,WAFJ,SAEsB,sBAAOT,MAAM,CAAb,EAAgBC,QAAQS,OAAxB,CAFtB,QAAP;AAGD,C","file":"formatComplexDataStructure.js","sourcesContent":["/* @flow */\n\nimport { isValidElement } from 'react';\nimport stringify from '../stringifyObject';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = stringify(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return noRefCheck;\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n"]}
